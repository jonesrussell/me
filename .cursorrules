### Core Development Guidelines

#### **Testing Practices**
- Prioritize testing functionality over CSS implementations.
- Write unit tests for every component and test them in isolation.
- Focus on user interactions, state management, and accessibility during testing.
- Verify error handling and edge cases to ensure robustness.
- Utilize Vitest and Testing Library for test execution.
- Mock external dependencies to simulate realistic scenarios.
- Incorporate edge case testing and use fixtures for consistency.
- Build test utilities for common setups and follow the Arrange-Act-Assert (AAA) pattern.
- Use snapshot testing to confirm rendering consistency.
- Evaluate component rendering, validate props, and check child element rendering.
- Include asynchronous testing and assess component structure, style application, and responsiveness.
- Avoid relying on test IDs; instead, utilize semantic HTML, roles, and labels for meaningful tests.

---

#### **Branding**
- Title: Russell Jones
- Description: Crafting elegant solutions with modern web technologies.

---

#### **General Development Rules**
- Embrace TypeScript for safer and more maintainable code.
- Keep your code well-documented with comments and updated documentation.
- Adhere to SOLID principles for clean architecture.
- Focus on pure functions, minimize side effects, and use strict type checking.
- Validate props at runtime and gracefully handle edge cases.
- Implement consistent error handling practices.

---

#### **Code Style**
- Use semicolons consistently and favor strict types.
- Prefer `const` where applicable, and limit lines to 100 characters.
- Indent with tabs (2 spaces per tab) for readability.
- Follow a consistent naming convention, prefix interfaces with "I," and suffix types with "Type."
- Name tests descriptively, group related ones, and ensure clear structure with case documentation.

---

#### **Separation of Concerns**
- Organize files by feature and isolate UI components from business logic.
- Ensure services are stateless and use dependency injection for flexibility.
- Minimize logic within components and maintain test independence through utility separation.

---

#### **Type Organization**
- Centralize shared types and use aliases for clarity.
- Prefer interfaces over type aliases and document complex types.
- Group related types and create type utilities for testing and components.
- Export types separately for better module management.

---

#### **Services**
- Use service factories and implement error handling mechanisms.
- Add request caching, retry logic, timeouts, and middleware for service stability.
- Mock services during testing, validate responses, and test error scenarios.

---

#### **Store Management**
- Build custom stores with subscriptions, derivations, and persistence.
- Implement actions and middleware, keeping stores lightweight and focused.
- Test updates, subscriptions, and derivations thoroughly.

---

#### **Svelte Patterns**
- Leverage runes and prefer `$state` over `let` variables.
- Use `$derived` instead of computed properties and `$effect` for side effects.
- Apply TypeScript for props and design components to be small and semantic.
- Favor render functions over slots, validate props, and implement error boundaries.
- Test component props, events, state, and effects methodically.

---

#### **Monospace Design**
- Utilize monospace fonts aligned to character grids for precision.
- Ensure consistent spacing and maintain visual hierarchy in layouts.
- Test responsive designs, typography scales, color contrasts, and spacing rigorously.

---

#### **Best Practices**
- Handle errors gracefully and validate user input effectively.
- Optimize performance and follow accessibility standards.
- Adopt semantic versioning and keep dependencies up-to-date.
- Incorporate progressive enhancement, secure coding guidelines, and analytics.
- Monitor performance and write maintainable, well-documented tests with consistent patterns.
